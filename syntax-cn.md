Lumesh Shell 语法手册
---

## 一、基础语法结构

1. **变量声明与赋值**
   - **声明变量**：使用 `let` 关键字，支持多变量声明。
     ```bash
     let x = 10                 # 单变量
     let a, b = 1, "hello"      # 多变量分别赋值（右侧表达式数量必须匹配）
     let a, b, c = 1            # 多变量统一赋值
     let a = b = 1              # 多变量连续赋值
     ```

     利用let，创建别名
     ```bash
     let cat = bat
     ```

     利用let，不仅可以定义变量为字符串，labmda函数，macro宏, command命令，还可以自定义操作符


   - **赋值操作符**：
     - `=`：普通赋值。
     - `:=`：延迟赋值（将表达式作为引用存储）。
     ```bash
     x := 2 + 3  # 延迟求值，存储表达式而非结果
     echo x      # 输出表达式： 2+3
     eval x      # 输出结果： 5
     ```
   - **删除变量**：使用 `del`。
     ```bash
     del x
     ```
   - **使用变量**：无须$,直接使用 `echo a x`。

   **边缘情况**：
   - 严格模式（`-s`）下，变量必须初始化，否则报错。
   - 多变量声明时，右侧表达式数量必须与左侧变量数量一致或统一一个值，否则抛出 `SyntaxError`。

2. **数据类型**
   - **基本类型**：
     | 类型       | 示例                     |
     |-----------|--------------------------|
     | 整数       | `42`, `-3`               |
     | 浮点数     | `3.14`, `-0.5`           |
     | 字符串     | `"Hello\n"`, `'raw'`      |
     | 布尔值     | `True`, `False`           |
     | 列表       | `[1, "a", True]`          |
     | 映射（字典）| `{name: "Alice", age: 30}`|
     | `None`     | `None`                    |

   - **复杂类型**：
     | 类型       | 示例                     |
     |-----------|--------------------------|
     | 变量     | `x`                    |
     | 函数     | `fn add(x,y){return x+y}`    |
     | lambda     | `let add = x -> y -> x + y`  |
     | bultin     | `math@floor`  |

   - **字符串规则**：
     - 双引号支持转义（如 `\n`），单引号为原始字符串。

     ```bash
     let str = "Hello\nworld!"   #输出两行, 看不到\n
     let str2 = 'Hello\nworld!'  #输出一行，原始字符串包括\n
     ```

   **边缘情况**：
   - 单引号字符串中的 `\` 按字面处理（如 `'Line\n'` 输出 `Line\n`）。

3. **作用域规则**
   - lambda, function函数 视为子环境
   - 子环境继承父环境变量，不修改父作用域。

---

## 二、运算符规则
<!-- > 操作符可通过`ops`命令查看 -->

### 1. 运算符分类与优先级

**优先级从高到低**（数值越小优先级越高）

| 优先级 | 运算符/结构              | 示例/说明                  |
| --- | ------------------- | ---------------------- |
| 1   | 括号 `()`             | `(a + b) * c`          |
| 2   | 函数调用、列表 `[]`        | `func arg`, `[1, 2]`   |
| 3   | 单目运算符 `!`, `-`, `__..`  | `!flag`, `-5`          |
| 4   | 幂运算 `**`            | `2 ** 3`               |
| 5   | 乘除模 `*`, `/`, `%`, `_*..` | `a * b % c`            |
| 6   | 加减 `+`, `-` ,`_+..`         | `a + b - c`            |
| 7   | 比较 `==`, `!=`, `>`等 | `a > b                 |
| 8   | 逻辑与 `&&`            | `cond1 && cond2`       |
| 9   | 逻辑或 `||`          |                        |
| 10  | 条件运算符 `?:`          | `cond ? t : f`         |
| 11  | 赋值 `=`, `:=`        | `x = 5`, `let y := 10` |
| 12  | 管道 `|`                | `ls | sort`               |
| 13  | 重定向 `<<` `>>` `>>>`   | `date >> /tmp/day.txt`      |

### 2. 空格规则
| 运算符类型         | 是否需要空格                | 示例                    |
|-------------------|---------------------------|-------------------------|
| 常规运算符         | 两侧应空格                  | `a + b` `x <= 10`       |
|                  | 非严格模式，部分符号两侧可以不空格  | `a+b` `x<=10` `a=5`      |
|                  |          `-`和`/`应空格       | `b-3`为字符串，`3-b`为减法 |
| 自定义运算符       | 必须用下划线开头且两侧空格     | `x _*+ y` `a _?= b`     |
|                  | 后缀运算符，必须用双下划线开头且两侧空格     | `x __*+`     |
| 前缀运算符         | 前面为空格或开始，后面无空格                  | `!x`  `-7`                 |
| 中缀运算符           | 前后均无空格                  | `dict.key`   `1..9`      |
| 后缀运算符           | 前后均无空格                  | `func(a)`   `array[i]`      |
|                       |    未来可能废弃，不推荐使用              | `a++`   `a--`      |

a++ 推荐用 a += 1
因为 -- 在shell中通常用于参数传递。所以不建议使用a--

**自定义操作符**
- 自定义操作符是以 `_`开头的符号，只能包含符号，不能包含数字或字母。
- 自定义单目运算符 以 `__`开头，如`__+`, 优先级同单目运算符。仅能用于后缀运算。
- 自定义+级运算符 以 `_+`开头，如`_+%`，优先级同`+` `-`
- 自定义*级运算符 以 `_*`开头，如`_*-`，优先级同`*` `/`

```bash
let __++ = x -> x + 1;
3 __++
```

**边缘情况**：
- `x++y` 非法， `x+++y`合法。
---


### 3. 隐式类型转换
```bash
# 非严格模式
3 + "5"    # → "35"（自动转字符串）
"10" * 2   # → 20

# 严格模式（启动时加 -s）
3 + "5"    # → TypeError: 无法把字符串和数字相加
"10" * 2   # → "1010"
```

### 4. 特殊运算行为
```bash
"5" + "3"  # → "53"
"5" * 3    # → "555" (非严格模式)
5 / 2      # → 2（整数除法）
5.0 / 2    # → 2.5
```
_可用*让字符串,列表，重复多次，类似python用法_
`echo "+" * 3`
`[3,5,7] * 3`


**边缘情况**：
- 除以零会报错。

### 5. 管道
- `|` 管道到标准输出
- `|>` 管道到末尾参数

### 6. 重定向
- `<<` 读取
- `>>` 输出
- `>>>` 追加输出

`1 + 2 >> result.txt`

---

## 三、数组与字典索引

### 1. 数组操作
```bash
let arr = [10, "a", True]

# 基础索引
arr@0
arr.1
arr[1]

arr[0]       # → 10
arr[-1]      # → True（支持负数索引）

# 切片操作
arr[1:3]     # → ["a", True]（左闭右开）
arr[::2]     # → [10, True]（步长2）

# 复杂嵌套
[1,24,5,[5,6,8]][3][1]     # 显示6
# # 修改元素
# arr[2] = 3.14 # → [10, "a", 3.14]
```
**边缘情况**：
- 数组索引如果超出边界，会触发`out of bounds`错误
- 数组切片支持负数，表示从后往前数的index
- 如果对不能索引的对象进行索引，会触发如下错误：
`[ERROR] type error: expected indexable type (list/dict/string), found symbol`

### 2. 字典操作
```bash
let dict = {name: "Alice", age: 30}
--let dict = {name="Alice", age=30}-- #已废弃

# 基础访问
dict@name
dict.name
# dict["name"]     # → "Alice"
# dict.name        # → "Alice"（简写形式）

# # 动态键支持
# let key = "ag" + "e"
# dict[$key]       # → 30

# # 嵌套访问
# let data = {user: {profile: {id: 100}}}
# data.user.profile.id # → 100
```

**边缘情况**：
| 场景                          | 行为                           |
|------------------------------|--------------------------------|
| 访问不存在的数组索引          | 触发`[ERROR] key `x` not found in map`错误            |
| 对非字典对象进行索引          | 触发 `[ERROR] not valid index option` 错误  |
| 对未定义的符号进行索引        | 返回字符串，因为shell中操作文件名是最常见的操作 |
| 对未定义的符号进行索引        | 返回字符串，因为shell中操作文件名是最常见的操作 |

---

### 3. 链式运算
```bash
let x = 5
x += 3 * (2 ** 4)  # x = 5 + 48 = 53
```

### 4. 动态索引
```bash
["a", "b", "c"]@((1 + 1) % 3)  # 暂不支持
```

## 四、语句

1. 语句块
  用 `{}` 表示。一般用于流程控制语句。

2. 语句组
  用括号表示子命令,子命令不新建进程，不隔离变量作用域。
  `echo (len [5,6])`

3. 语句
  用 `;` 或 `enter` 分割

  - **换行符**： `;`或回车。

  - **续行符**：使用 `\` + 换行符跨行书写。

   ```bash
   let long_expr = 3 \
                + 5  # 等价于 "3 + 5"

   let long_str = "Hello
                   World"  # 等价于 "Hello\n World"
   ```
注意：引号内的内容无须换行符。

---


## 五、控制结构

1. **条件语句**
   - **If 条件**
   支持嵌套：
   `if cond1 { ... } else if cond2 { ... } else { ... }`

   不使用 `then` 关键字，代码块用 `{}` 包裹。
      ```bash
      if True {1} else {if False {2} else {3}}

      if x > 10 {
          print("Large")
      } else if x == 10 {
          print("Equal")
      } else {
          print("Small")
      }
      ```

   - **Match 语句**
   替代bash的switch语句。
      ```bash
      let x = "a"
      match x {
      "b" => echo "is letter",
      _ => echo "is others"}
      ```

2. **循环**
   - **For 循环**：范围使用 `to`（左闭右开）。
     ```bash
     for i in 0 to 5 {    # 输出 0,1,2,3,4
         print(i)
     }

     for i in [1,5,8] { echo i }
     ```
   - **While 循环**：
     ```bash
     let count = 0
     while count < 3 {
         print(count)
         count = count + 1
     }
     ```

3. **语句表达式**

  控制语句也可以作为表达式使用：
   ```bash
   let a = if b>0 {5} else {-5}

   **边缘情况**：
   - `to` 的结束值不包含在迭代范围内。
   ```

---

## 六、函数

1. **函数定义**
   - 使用 `fn` 定义，支持默认参数，支持 `return`。
   ```bash
   fn add(a,b,c=10) {
      return  a + b + c
   }

   # 等价于：
   fn add(a,b,c=10) {
      a + b + c
   }

   echo add(2, 3)  # 输出 5
   ```
2. **lambda表达式**
   - 使用 `->` 定义。
   lambda 与 普通函数的区别：
      + lambda 不支持默认参数和return语句。
      + lambda 支持部分参数应用，返回后续lambda
   相同的是：lambda和函数都 继承当前环境变量，在隔离的环境中运行，不会污染当前环境。

   ```bash
   let add = (x,y) -> x + y
   ```

3. **macro 宏**，匿名宏（在当前作用域有效）：
  macro在当前环境运行，不进行环境隔离。

   ```bash
    x ~> x + 1
   ```

4. **函数调用**
   - 调用函数 参数并列。
   ```bash
   # 自定义函数可以这样调用
   add(3,5)
   # 或者这样
   add! 3 5   #注意需要添加!后缀，用以区别于命令调用。

   # 命令调用：
   ls -l

   # 内置命令支持上面三种调用方式
   fmt.red(msg)
   fmt.red! msg
   fmt.red msg
   ```

   **边缘情况**：
   - 函数名冲突时，新定义会覆盖旧模块。
   - 调用函数时，参数数量不匹配会报错。如：
   `[ERROR] arguments mismatch for function `add`: expected 3, found 1`

---


## 七. 参数与环境变量
1. **命令行参数**：
   - 脚本参数通过 `argv` 列表访问。
   ```bash
   # 运行 lumesh script.lsh Alice tom
   echo argv  # 输出 "[Alice, tom]"
   echo argv@0  # 输出 "Alice"
   ```
2. **环境变量**
   ```bash
   PATH             #系统环境变量
   HOME             #系统环境变量

   env              #列出所有当前环境变量
   IS_LOGIN         #是否LOGIN-SHELL
   IS_INTERACTIVE   #是否交互模式
   IS_STRICT        #是否严格模式
   ```

## 六、运行模式

1. REPL 交互模式
  用户交互模式，处理用户输入输出，高亮代码。
   **快捷键与命令**：
   - `Right`：自动补全（支持路径和历史命令）。
   - `Ctrl+C`：终止当前操作。
   - 特殊命令：`cd`, `exit`, `clear`。

   **历史记录**：保存在 `~/.lumesh-history`。

2. 脚本解析模式
  运行脚本： ```lume ./my.lsh```

3. LOGIN-SHELL模式
  启动shell，应配置好系统环境变量。类似.bashrc的内容，到config文件。

4. 严格模式
严格模式下，变量必须申明，不能重复申明。

非严格模式下，允许操作符周围没有空格。允许隐式转换数据类型。

---

## 七、内置函数

通过 `help builtin` 命令查看。

> 控制台操作
+ echo
+ print
+ println

- input
- cd
- prompt
- incomplete_promt
`let x = input "your choice:"`

+ help
+ exit
+ quit

> 对表达式的操作
+ `unbind` 取消变量
+ `eval` 执行表达式字面量代表的函数
+ `str` 获取表达式的字面量
+ `report` 同str

> 对列表的操作
- `len` 返回 列表/字典/字符串 的长度
- `chars` 字符串转为 单字符列表
- `lines` 字符串按行分割为列表
- `insert` 列表插入
`insert [1,2,4] 2 3`

> 时间
- `time.seconds` 当日过去的秒数
- `time.stamp` Unix时间戳

> 帮助文件未列出的

- pwd
- clear
- join 列表转字符串



## 内置Lib库

通过 `help lib` 命令查看。

使用时需要通过 lib_name@fn_name 的方式引用。

详细内容，请继续阅读: [内置Lib库](lib.md)

通过本手册，用户可掌握 Lumesh 的核心语法及边缘情况。建议结合 REPL 实践以加深理解。
